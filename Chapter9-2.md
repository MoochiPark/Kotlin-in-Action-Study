# 09. 제네릭스

# 

## 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터



자바 개발자라면 알고 있듯이 JVM의 제네릭스는 보통 **타입 소거**(type erasure)를 사용해 구현된다.

즉, 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 것이다.



이번에는 코틀린에서 타입 소거가 실용적인 면에서 어떤 영향을 끼치는지 살펴보고,

함수를 `inline`으로 선언함으로써 이런 제약을 어떻게 우회할 수 있는지 알아본다.

함수를 `inline`으로 만들면 타입 인자가 지워지지 않게 할 수 있다. 이를 코틀린에선 **실체화**(reify)라 부른다.



실체화된 타입 파라미터에 대해 자세히 다루고 실체화한 타입 파라미터가 유용한 이유를 알아보자.





### 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트



자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에서 지워진다.

이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 것이다.

예를 들어, `List<String>` 객체를 만들고 그 안에 문자열을 넣더라도 실행 시점에는 이 객체는 오직 `List`로만 볼 수 있다. 

그 `List` 객체가 어떤 타입의 원소를 저장하는지 실행 시점에는 알 수 없다.

실제로 코드를 실행할 때 어떤 일이 벌어지는지 알아보자.

<img title="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/cfeb5c60-c1df-477c-86c6-e0fbb0615672/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211228T002844Z&X-Amz-Expires=86400&X-Amz-Signature=cf1352037ae05e1e3a28495206c3071be4c0a44992e4daca5244b9aa36a25510&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject" alt="Untitled" data-align="center" width="545">

컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만 실행 시점에 이 둘은 완전히 같은 타입의 객체다.

하지만 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해주므로 각각 문자열과 정수만 들어있다고 보통은 가정할 수 있다.



이젠 타입 소거로 인해 생기는 한계에 대해 알아보자.

먼저, 타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.

예를 들어 어떤 리스트가 문자열로 이뤄진 리스트인지 다른 객체로 이뤄졌는지 실행 시점에 검사할 수 없다.

일반적으로 발하면 `is` 검사에서 타입 인자로 지정한 타입을 검사할 수는 없다.

```kotlin
>>> if (value is List<String>) { ... }
ERROR: Cannot check for instance of erased type
```

실행 시점에 어떤 값이 `List`인지 여부는 알아낼 수 있지만 그 리스트가 `String`의 리스트인지 `Person`의 리스트인지는 알 수가 없다.



하지만, 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 `is` 검사를 수행하게 해준다. 

```kotlin
fun printSum(c: Collection<Int>) {
    if (c is List<Int>) {
        println(c.sum())
    }
}

>>> printSum(listOf(1, 2, 3))
6
```

`c` 컬렉션이 `Int` 값을 저장한다는 사실이 알려져 있으므로 `c`가 `List<Int>`인지 검사할 수 있다.



다만 타입 소거는 저장해야 하는 타입 정보의 크기가 줄어들어 메모리 사용량이 줄어든다는 나름의 장점이 있긴하다.



9.1에서 말한 대로 코틀린에서는 타입 인자를 명시하지 않고 제네릭을 사용할 순 없다.

그렇다면 어떤 값이 단지 집합이나 맵이 아니라 리스트라는 사실만 알고싶을 땐 어떻게 확인할까?

바로 **스타 프로젝션**(star projection)을 사용하면 된다.

```kotlin
if (value is List<*>) { ... }
```

스타 프로젝션에 대해서는 뒤에서 더 알아보고, 지금은 인자를 알 수 없는 제네릭 타입을 표현할 때 사용한다고 알아두자. *(자바의 List<?>와 비슷함)*

### 9.2.2 실체화된 타입 파라미터를 사용한 함수 선언



코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다고 했다.

따라서 제네릭 클래스의 인스턴스가 있어도 그 인스턴스를 만들 때 사용한 타입 인자를 알아낼 수 없다. 이것은 제네릭 함수의 타입 인자도 마찬가지이다.

제네릭 함수가 호출되도 그 함수의 본문에서 호출 시 쓰인 타입 인자를 알아낼 수 없다.

```kotlin
>>> fun <T> isA(value: Any) = value is T
Error: Cannot check for instance of erased type: T
```

하지만 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 타입 인자를 알 수 있다.



8.2절에서 `inline` 함수에 대해 알아봤다.

어떤 함수에 `inline` 키워드를 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수 본문으로 바꾼다.

함수가 람다를 인자로 사용하는 경우 그 함수를 인라인 함수로 만들면 람다 코드도 함께 인라이닝되고, 그에 따라 무명 클래스와 객체가 생성되지 않아 성능이 향상될 수 있다.



이번에는 인라인 함수가 유용한 다른 이유인 타입 인자 실체화에 대해 알아보자.

위의 `isA` 함수를 인라인 함수로 만들고 타입 파라미터를 `reified`로 지정하면 `value`의 타입이 `T`의 인스턴스인지를 실행 시점에 검사할 수 있다.

```kotlin
inline fun <reified T> isA(value: Any) = value is T

>>> println(isA<String>("abc"))
true
>>> println(isA<String>(123))
false
```

실체화된 타입 파라미터를 사용하는 예를 알아보자.

가장 간단한 예제 중 하나로 표준 라이브러리 함수인 `filterIsInstance`가 있다.

```kotlin
>>> val items = listOf("one", 2, "three")
>>> println(items.filterIsInstance<String>())
[one, three]
```

`filterIsInstance`의 타입인자로 `String`을 지정함으로써 문자열만 필요하다는 사실을 기술한다.

> 인라인 함수에서만 실체화한 타입 인자를 쓸 수 있는 이유

실체화한 타입 인자는 어떻게 작동하는 걸까?

왜 일반 함수에서는 `element is T`를 사용할 수 없고 인라인 함수에서만 쓸 수 있는가?

이전에 설명했던 것처럼 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다.

컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다.

따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.

결과적으로 위의 예제는 아래와 같은 코드를 만들어낸다.

```kotlin
for (element in this) {
  if (element is String) {
    destination.add(element)
  }
}
```

타입 파라미터가 아니라 구체적 타입을 사용하므로 만들어진 바이트코드는 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는 것이다.

### 9.2.3 실체화한 타입 파라미터의 제약



실체화한 타입 파라미터는 유용한 도구지만 몇 가지 제약이 있다.

일부는 실체화의 개념으로 인해 생기는 제약이며, 나머지는 코틀린이 실체화를 구현하는 방식에 의해 생기는 제약이다.



다음과 같은 경우에는 실체화한 타입 파라미터를 사용할 수 있다.

- 타입 검사와 캐스팅(`is`, `!is`, `as`, `as?`)

- 10장에서 설명할 코틀린 리플랙션 API(`::class`)

- 코틀린 타입에 대응하는 `java.lang.Class`를 얻기(`::class.java`)
  
  ```kotlin
  inline fun <reified T : Activity>
          Context.startActivity() {
      val intent = Intent(this, T::class.java)
      startActivity(intent)
  }
  
  startActivity<DetailActivity>()
  ```

- 다른 함수를 호출할 때 타입 인자로 사용



하지만 다음과 같은 일은 할 수 없다.

- 타입 파라미터 클래스의 인스턴스 생성하기
- 타입 파라미터 클래스의 동반 객체 메서드 호출하기
- 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
- 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 `reified`로 지정하기



마지막으로, 인라인 함수는 자신에게 전달되는 모든 람다와 함께 인라이닝된다.

따라서 인라이닝을 파급하고 싶지 않은 경우에 8장에서 배운 `noinline` 변경자를 함수 타입 파라미터에 붙여서 인라이닝을 금지할 수도 있다.